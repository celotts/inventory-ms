#------------------------------------------------------------------------
# ü¶≠ Makefile para Podman - Sistema de Microservicios InventoryMS
#------------------------------------------------------------------------
# ‚úÖ MODIFICADO: Definici√≥n del directorio de build temporal para la autenticaci√≥n
BUILD_DIR := $(CURDIR)/.build
AUTH_FILE := $(BUILD_DIR)/config.json
#------------------------------------------------------------------------
# üì¶ Variables de entorno y configuraci√≥n
#------------------------------------------------------------------------
CURDIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))
ROOT_DIR := $(abspath $(CURDIR)/..)
GRADLEW := $(ROOT_DIR)/gradlew

IF_ENV_EXISTS := $(wildcard $(CURDIR)/.env.local)

DOCKER_COMPOSE_BIN := /opt/homebrew/bin/docker-compose
COMPOSE_FILE := docker-compose-podman.yml
ENV_FILE_PATH := $(CURDIR)/.env.local

# Esta forma es m√°s segura para que Make no rompa los argumentos
DOCKER_COMPOSE := $(DOCKER_COMPOSE_BIN) -f $(COMPOSE_FILE) --env-file $(ENV_FILE_PATH)

# Archivos de entorno
ENV_FILE_LOCAL ?= $(CURDIR)/.env.local
ENV_FILE_LOCAL_SUPPLIER ?= $(CURDIR)/.env.local-supplier
ENV_FILE_LOCAL_SUPPLIER_TAX ?= $(CURDIR)/.env.local-supplier-tax
ENV_FILE_DEV ?= $(CURDIR)/.env.dev
ENV_FILE_PROD ?= $(CURDIR)/.env.prod

# Resoluci√≥n de archivos de entorno
ENV_SUPPLIER_FALLBACK ?= $(ENV_FILE_LOCAL)
ENV_FILE_LOCAL_SUPPLIER_RESOLVED := $(if $(wildcard $(ENV_FILE_LOCAL_SUPPLIER)),$(ENV_FILE_LOCAL_SUPPLIER),$(ENV_SUPPLIER_FALLBACK))
ENV_FILE ?= $(ENV_FILE_LOCAL_SUPPLIER_TAX)
ENV_FILE_RESOLVED := $(if $(wildcard $(ENV_FILE)),$(ENV_FILE),)

# Configuraci√≥n de Compose
COMPOSE_FILE ?= docker-compose-podman.yml
COMPOSE_FILE_OPTIMIZED := docker-compose-optimizado-podman.yml  # <--- Definir el nuevo archivo
COMPOSE_PROJECT_NAME ?= inventoryms
COMPOSE_PROVIDER ?= podman
export DOCKER_BUILDKIT := 1
export COMPOSE_DOCKER_CLI_BUILD ?= 1 # Habilitar BuildKit

# Perfiles y servicios (PURCHASE/purchase-service excluidos)
PROFILES_BUILD_ORDER := infra gateway product supplier tax purchase
# Servicios que necesitan construcci√≥n de im√°genes (ordenados)
SERVICES_TO_BUILD := discovery-service config-service api-gateway product-service supplier-service tax-service purchase-service

# Puertos de servicios
PRODUCT_PORT ?= 9090
SUPPLIER_PORT ?= 9091
PURCHASE_PORT ?= 9092
TAX_PORT ?= 9093
GATEWAY_PORT ?= 8090
DISCOVERY_PORT ?= 8761
CONFIG_PORT ?= 7777

# Perfiles y servicios (PURCHASE/purchase-service excluidos)
PROFILES_ALL := infra gateway product supplier tax purchase
SERVICES_ALL := discovery-service config-service api-gateway product-service supplier-service tax-service purchase-service

# Comandos base
RUN := COMPOSE_PROVIDER=$(COMPOSE_PROVIDER) COMPOSE_PROJECT_NAME=$(COMPOSE_PROJECT_NAME)
COMPOSE_BASE := $(RUN) podman compose -f $(COMPOSE_FILE)
COMPOSE_OPTIMIZED := $(RUN) podman compose -f $(COMPOSE_FILE_OPTIMIZED) --env-file $(ENV_FILE_LOCAL) # <--- Comando para el archivo optimizado
# Comandos espec√≠ficos por entorno
COMPOSE_LOCAL := $(COMPOSE_BASE) --env-file $(ENV_FILE_LOCAL)
COMPOSE_LOCAL_SUPPLIER := $(COMPOSE_BASE) --env-file $(ENV_FILE_LOCAL_SUPPLIER_RESOLVED)
COMPOSE_DEV := $(COMPOSE_BASE) --env-file $(ENV_FILE_DEV)
COMPOSE_PROD := $(COMPOSE_BASE) --env-file $(ENV_FILE_PROD)

PURCHASE_SERVICE_NAME := purchase-service

# Extraer valores de tu .env.local
#D_USER := $(shell grep "^DOCKER_USERNAME=" .env.local | cut -d'=' -f2)
#D_PASS := $(shell grep "^DOCKER_PASSWORD=" .env.local | cut -d'=' -f2)

D_USER := $(shell grep "^DOCKER_USERNAME=" .env.local | cut -d'=' -f2 | tr -d '\r' | xargs)
D_PASS := $(shell grep "^DOCKER_PASSWORD=" .env.local | cut -d'=' -f2 | tr -d '\r' | xargs)
#------------------------------------------------------------------------
# üì¶ Carga de variables de entorno para Make
#------------------------------------------------------------------------
ifneq ("$(wildcard .env.local)","")
    include .env.local
    export $(shell sed 's/=.*//' .env.local)
endif

# Variables de utilidad para salida limpia
Q := @
ifndef VERBOSE
.SILENT:
endif


#------------------------------------------------------------------------

# üí° MACROS DE UTILIDAD
define check_health
	curl -f --max-time 20 $(1) >/dev/null 2>&1 && echo "‚úÖ $(2)" || echo "‚ùå $(2)"
endef

#üéØ COMANDOS PRINCIPALES - FLUJOS DE TRABAJO ESENCIALES
#------------------------------------------------------------------------

#üöÄ INICIAR SERVICIOS
start: up-local ## üöÄ Iniciar servicios base (Infra + Product + Gateway)
start-all-LEVANTA-SIN-ERROR-CONTENEDORES: up-local-all-ordered ## üöÄ Iniciar TODOS los servicios
start-parallel: up-local-all ## üöÄ Iniciar todos los servicios en paralelo

#üõë DETENER SERVICIOS
stop: down-all ## üõë Detener todos los servicios

#üîÑ REINICIAR SERVICIOS
restart: stop start ## üîÑ Reiniciar servicios base
restart-all: stop start-all ## üîÑ Reiniciar todos los servicios

#üõ†Ô∏è DESARROLLO
dev: up-local ## üß™ Entorno de desarrollo base
dev-full: up-local-all-ordered ## üß™ Entorno de desarrollo completo
dev-supplier: up-local-supplier ## üß™ Entorno de desarrollo con Supplier
dev-tax: up-local-with-tax ## üß™ Entorno de desarrollo con Tax

#üèóÔ∏è CONSTRUCCI√ìN
build-all: fix-line-endings build-jars-all ## üî® Construir todos los servicios
build-jars: fix-line-endings ## üî® Construir JARs base
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :config-service:bootJar :discovery-service:bootJar :api-gateway:bootJar :product-service:bootJar

build-jars-all: fix-line-endings ## üî® Construir TODOS los JARs
	@echo "üî® Construyendo todos los JARs..."
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :config-service:bootJar :discovery-service:bootJar :api-gateway:bootJar :product-service:bootJar :supplier-service:bootJar :tax-service:bootJar :purchase-service:bootJar

build-images-all-nocache: build-jars-all ## üî® Construye TODAS las im√°genes sin cach√© (SERIAL)
	@echo "üî® Construyendo im√°genes SIN cach√© para todos los servicios (SERIAL)..."
	export DOCKER_CONFIG=$(BUILD_DIR); \
	echo "   [1/6] Construyendo discovery-service y config-service..."; \
	$(COMPOSE_LOCAL) --profile infra build --no-cache \
		--build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
		discovery-service config-service; \
	echo "   [2/6] Construyendo product-service..."; \
	$(COMPOSE_LOCAL) --profile infra --profile product build --no-cache \
		--build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
		product-service; \
	echo "   [3/6] Construyendo supplier-service..."; \
	$(COMPOSE_LOCAL) --profile infra --profile supplier build --no-cache \
		--build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
		supplier-service; \
	echo "   [4/6] Construyendo tax-service..."; \
	$(COMPOSE_LOCAL) --profile infra --profile tax build --no-cache \
		--build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
		tax-service; \
	echo "   [5/6] Construyendo purchase-service..."; \
        $(COMPOSE_LOCAL) --profile infra --profile purchase build --no-cache \
           --build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
           purchase-service; \
	echo "   [6/6] Construyendo api-gateway..."; \
        $(COMPOSE_LOCAL) --profile infra --profile gateway build --no-cache \
		--build-arg DOCKER_USERNAME=$(D_USER) --build-arg DOCKER_PASSWORD=$(D_PASS) \
		api-gateway; \
	echo "‚úÖ Construcci√≥n de todas las im√°genes completada en SERIAL."
#------------------------------------------------------------------------

#üß™ TESTING
test-all: fix-line-endings ## üß™ Ejecutar todos los tests
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) test
test-quick: test-product test-supplier test-tax ## üß™ Tests r√°pidos de servicios principales

#üìä MONITOREO
status: podman-ready ## üìä Estado de todos los servicios
	$(COMPOSE_LOCAL) ps
status-all: status ## üìä Alias para status

logs: podman-ready ## üìú Logs de todos los servicios
	$(COMPOSE_LOCAL) logs -f

health: health-check-extended ## üíö Verificaci√≥n de salud completa

# --- Autenticaci√≥n Autom√°tica ---
podman-auth2:
	@echo "üîë Configurando autenticaci√≥n autom√°tica para Podman..."
	@# Extraemos las credenciales directamente del archivo .env.local
	$(eval DOCKER_USER := $(shell grep DOCKER_USERNAME $(ENV_FILE_LOCAL) | cut -d'=' -f2))
	$(eval DOCKER_PASS := $(shell grep DOCKER_PASSWORD $(ENV_FILE_LOCAL) | cut -d'=' -f2))
	@echo "Iniciando sesi√≥n en docker.io como $(DOCKER_USER)..."
	@echo "$(DOCKER_PASS)" | podman login docker.io -u "$(DOCKER_USER)" --password-stdin

podman-auth1: ## üîë Autenticar en Docker Hub usando .env.local
	@echo "üîë Configurando autenticaci√≥n autom√°tica para Podman..."
	-podman logout docker.io > /dev/null 2>&1
	$(eval DOCKER_USER := $(shell grep "^DOCKER_USERNAME=" $(ENV_FILE_LOCAL) | cut -d'=' -f2 | tr -d '\r' | xargs))
	$(eval DOCKER_PASS := $(shell grep "^DOCKER_PASSWORD=" $(ENV_FILE_LOCAL) | cut -d'=' -f2 | tr -d '\r' | xargs))
	@if [ -z "$(DOCKER_USER)" ] || [ -z "$(DOCKER_PASS)" ]; then \
		echo "‚ùå Error: Credenciales no encontradas en $(ENV_FILE_LOCAL)"; \
		exit 1; \
	fi
	@echo "Iniciando sesi√≥n en docker.io como $(DOCKER_USER)..."
	@echo "$(DOCKER_PASS)" | podman login docker.io -u "$(DOCKER_USER)" --password-stdin || (echo "‚ùå Error de login"; exit 1)

podman-auth: ## üîë Autenticar y asegurar imagen base
	@echo "üîë Configurando autenticaci√≥n autom√°tica para Podman..."
	$(eval D_USER := $(shell grep "^DOCKER_USERNAME=" $(ENV_FILE_LOCAL) | cut -d'=' -f2 | tr -d '\r' | xargs))
	$(eval D_PASS := $(shell grep "^DOCKER_PASSWORD=" $(ENV_FILE_LOCAL) | cut -d'=' -f2 | tr -d '\r' | xargs))
	@echo "Iniciando sesi√≥n en docker.io como $(D_USER)..."
	@echo "$(D_PASS)" | podman login docker.io -u "$(D_USER)" --password-stdin || (echo "‚ùå Error de login"; exit 1)
	@echo "üì• Asegurando imagen base Java 21..."
	podman pull eclipse-temurin:21-jdk-jammy || (echo "‚ùå Error al descargar imagen base"; exit 1)
# ------------------------------------------------------------------------
# üöÄ TARGETS DE UP (INICIO)
# ------------------------------------------------------------------------
up-local: podman-ready fix-line-endings fix-container-orphans ## üß™ Infra + Product + Gateway
	@echo "üß™ Levantando: Infra + Product + Gateway"
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) $(MAKE) build-jars
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile product --profile gateway up -d --build --remove-orphans
up-local-all: podman-ready fix-line-endings fix-container-orphans
	@echo "üöÄ Levantando TODOS los microservicios (paralelo)..."
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) $(MAKE) build-images-all-nocache # Ahora este target es SERIAL
	$(Q) $(COMPOSE_LOCAL) $(foreach p,$(PROFILES_ALL),--profile $(p)) up -d --build --remove-orphans
	@echo "üîç Verificando salud de los servicios (espera 30s)..."
	$(Q) sleep 30
	$(Q) $(MAKE) health-check-extended

up-local-all-ordered2: podman-ready fix-line-endings ## üöÄ Stack completo sin duplicados y con m√©tricas
	# =========================================================
	# üîë PASO 0: AUTENTICACI√ìN Y LIMPIEZA PREVENTIVA
    # =========================================================
	@echo "üîë Configurando credenciales de Podman..."
	$(Q) D_USER=$$(grep "^DOCKER_USERNAME=" $(ENV_FILE_LOCAL) | cut -d'=' -f2); \
	D_PASS=$$(grep "^DOCKER_PASSWORD=" $(ENV_FILE_LOCAL) | cut -d'=' -f2); \
	if [ -n "$$D_USER" ]; then \
		echo "$$D_PASS" | podman login docker.io -u "$$D_USER" --password-stdin; \
	fi

	@echo "üßπ Limpiando procesos antiguos y hu√©rfanos..."
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile product --profile supplier --profile tax --profile gateway down --remove-orphans 2>/dev/null || true

	# =========================================================
	# ‚è±Ô∏è INICIO DEL REGISTRO DE TIEMPO
	# =========================================================
	@START_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
	START_SECONDS=$$(date +%s); \
	echo "================================================================================="; \
	echo "‚è±Ô∏è INICIO DEL PROCESO: $$START_TIME"; \
	echo "=================================================================================";

	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) $(MAKE) build-images-all-nocache

	# Definimos los perfiles una sola vez para evitar duplicados por contexto
	$(eval PROFILES := --profile infra --profile product --profile supplier --profile tax --profile gateway)

	@echo "üîß 1/4: Discovery y Config Services..."
	$(Q) $(COMPOSE_LOCAL) $(PROFILES) up -d discovery-service config-service
	$(Q) sleep 40

	@echo "üóÑÔ∏è 2/4: Bases de datos..."
	$(Q) $(COMPOSE_LOCAL) $(PROFILES) up -d db_product db_supplier db_tax
	$(Q) sleep 55

	@echo "üõ†Ô∏è 3/4: Microservicios (Product, Supplier, Tax, Purchase)..."
	$(Q) $(COMPOSE_LOCAL) $(PROFILES) up -d product-service supplier-service tax-service purchase-service
	$(Q) sleep 120

	@echo "üåê 4/4: API Gateway..."
	$(Q) $(COMPOSE_LOCAL) $(PROFILES) up -d api-gateway
	#$(Q) sleep 120

	@echo "üîç Verificaci√≥n final (espera 120s)..."
	$(Q) sleep 120
	$(Q) $(MAKE) health-check-extended

	@echo "üéâ STACK COMPLETO LEVANTADO!"

	# =========================================================
	# ‚è±Ô∏è FINAL DEL REGISTRO DE TIEMPO
	# =========================================================
	@END_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
	END_SECONDS=$$(date +%s); \
	DURATION_SECONDS=$$((END_SECONDS - START_SECONDS)); \
	HOURS=$((DURATION_SECONDS / 3600)); \
    MINUTES=$(( (DURATION_SECONDS % 3600) / 60 )); \
    SECONDS=$((DURATION_SECONDS % 60)); \
   	echo "================================================================================="; \
    echo "‚è±Ô∏è FIN DEL PROCESO: $END_TIME"; \
    printf "‚è≥ TIEMPO TOTAL DEMORADO: %02d:%02d:%02d\n" $HOURS $MINUTES $SECONDS; \
    echo "================================================================================="; \

.PHONY: test-purchase run-purchase-local rebuild-purchase-local purchase-db-reset
up-local-all-ordered: podman-ready fix-line-endings ## üöÄ Iniciar stack completo de forma secuencial
	@START_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
    START_SECONDS=$$(date +%s); \
	echo "================================================================================="; \
	echo "‚è±Ô∏è PROCESO INICIO: $$START_TIME"; \
	echo "================================================================================="; \
	$(MAKE) build-images-all-nocache; \
	\
	# 1. Definimos los perfiles incluyendo 'purchase'
	PROFILES="--profile infra --profile product --profile supplier --profile tax --profile purchase --profile gateway"; \
	\
	echo "üîß 1/4: Discovery y Config (Infraestructura)..."; \
	$(COMPOSE_LOCAL) $$PROFILES up -d discovery-service config-service && sleep 40; \
	\
	echo "üóÑÔ∏è 2/4: Bases de Datos (incluyendo db_purchase)..."; \
	$(COMPOSE_LOCAL) $$PROFILES up -d db_product db_supplier db_tax db_purchase && sleep 55; \
	\
	echo "üõ†Ô∏è 3/4: Microservicios (incluyendo purchase-service)..."; \
	$(COMPOSE_LOCAL) $$PROFILES up -d product-service supplier-service tax-service purchase-service && sleep 120; \
	\
	echo "üåê 4/4: API Gateway (Puerta de enlace)..."; \
	$(COMPOSE_LOCAL) $$PROFILES up -d api-gateway && sleep 120; \
	\
	echo "================================================================================="; \
	echo "üìä ESTADO FINAL DE LOS CONTENEDORES"; \
	echo "================================================================================="; \
	podman ps --format "{{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "service|db|discovery|config|gateway" | awk -F'\t' '{ \
    		status_icon = "‚ùå"; \
    		if ($$2 ~ /healthy/) status_icon = "‚úÖ"; \
    		else if ($$2 ~ /running/) status_icon = "üü°"; \
    		printf "%s %-20s %-25s %s\n", status_icon, $$1, $$2, $$3; \
    }'; \
    #@END_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
	END_SECONDS=$$(date +%s); \
	DURATION_SECONDS=$$((END_SECONDS - START_SECONDS)); \
	HOURS=$$((DURATION_SECONDS / 3600)); \
	MINUTES=$$(( (DURATION_SECONDS % 3600) / 60 )); \
	SECONDS=$$((DURATION_SECONDS % 60)); \
	END_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
	echo "================================================================================="; \
	echo "‚è±Ô∏è PROCESO INICIO...: $$START_TIME"; \
	echo "‚è±Ô∏è PROCESO CULMINADO: $$END_TIME"; \
	printf "‚è≥ TIEMPO TOTAL: %02d:%02d:%02d\n" $$HOURS $$MINUTES $$SECONDS; \
	echo "================================================================================="

.PHONY: build-purchase
build-purchase:
	@echo "üöÄ Construyendo $(PURCHASE_SERVICE_NAME)..."
	# DOCKER_BUILDKIT=0 desactiva el motor que est√° fallando
	# COMPOSE_DOCKER_CLI_BUILD=0 asegura el uso del constructor cl√°sico
	DOCKER_BUILDKIT=0 COMPOSE_DOCKER_CLI_BUILD=0 $(DOCKER_COMPOSE) --profile infra --profile purchase build --no-cache \
		--build-arg DOCKER_USERNAME=$(DOCKER_USERNAME) \
		--build-arg DOCKER_PASSWORD=$(DOCKER_PASSWORD) \
		$(PURCHASE_SERVICE_NAME)

.PHONY: ensure-script-exec
ensure-script-exec:
	# üö® Comando cr√≠tico: Garantizar permisos de ejecuci√≥n al script antes de usarlo.
	$(Q) chmod +x ensure_podman_ready.sh 2>/dev/null || true

.PHONY: up-purchase
up-purchase:
	@echo "‚úÖ Levantando $(PURCHASE_SERVICE_NAME)..."
	$(DOCKER_COMPOSE) --profile infra --profile purchase up -d $(PURCHASE_SERVICE_NAME)

.PHONY: down-purchase
down-purchase:
	@echo "Deteniendo $(PURCHASE_SERVICE_NAME)..."
	$(DOCKER_COMPOSE) --profile purchase stop $(PURCHASE_SERVICE_NAME)

.PHONY: logs-purchase
logs-purchase:
	$(DOCKER_COMPOSE) logs -f $(PURCHASE_SERVICE_NAME)

# ------------------------------------------------------------------------
# Targets de Herramientas y Diagn√≥stico (Versi√≥n FINAL que NO se Bloquea ni Causa Sintaxis)
# ------------------------------------------------------------------------
.PHONY: podman-ready
podman-ready: ## üîç Confirma el estado y asume que el Login fue manual.
	@echo "‚öôÔ∏è El entorno de Podman est√° siendo verificado..."
	@echo "‚úÖ Autenticaci√≥n y M√°quina Podman confirmadas manualmente. Continuando con la construcci√≥n."
	# Comprobaci√≥n simple para asegurar que Podman est√° disponible
	@podman machine ls >/dev/null 2>&1 || { echo "üö® ERROR: Podman machine no responde. Ejecute 'podman machine start' manualmente."; exit 1; }

up-local-supplier: docker-login podman-ready fix-line-endings fix-container-orphans ## üß™ Infra + Supplier
	@echo "üßπ Configurando entorno supplier..."
	$(Q) cp "$(ENV_FILE_LOCAL_SUPPLIER_RESOLVED)" "$(CURDIR)/.env.override"
	$(Q) $(MAKE) build-jars-all
	@echo "ü¶≠ Levantando supplier..."
	$(Q) $(COMPOSE_LOCAL_SUPPLIER) --profile infra --profile supplier up -d --build --remove-orphans

up-local-with-tax: podman-ready fix-line-endings fix-container-orphans ## üß™ Infra + Product + Gateway + Tax
	@echo "üßπ Configurando entorno con tax..."
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) $(MAKE) build-jars-all
	@echo "ü¶≠ Levantando servicios con tax..."
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile gateway --profile product --profile tax up -d --build --remove-orphans

#üîª DETENER SERVICIOS
down-local: podman-ready ## üîª Detener servicios locales
	$(COMPOSE_LOCAL) --profile infra --profile product --profile gateway down -v --remove-orphans
down-all: podman-ready ## üîª Detener TODOS los servicios
	@echo "üßπ Deteniendo todos los servicios..."
	$(COMPOSE_LOCAL) $(foreach p,$(PROFILES_ALL),--profile $(p)) down -v --remove-orphans

supplier-db-reset: podman-ready fix-line-endings ## üóÉÔ∏è Reiniciar base de datos de supplier
	@echo "üîÑ Reiniciando supplier-db y supplier-service..."
    # 1. Detener y eliminar el contenedor y su volumen de datos
	$(Q) $(COMPOSE_LOCAL) --profile supplier down -v db_supplier
    # 2. Reconstruir el JAR
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :supplier-service:bootJar
    # 3. Levantar la infra y el servicio del proveedor para recrear la DB
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile supplier up -d supplier-service

#üîç MONITOREO Y LOGS
logs-%: podman-ready ## üìú Logs por perfil
	$(COMPOSE_LOCAL) --profile $* logs -f

health-check-extended2: podman-ready ## üíö Verificaci√≥n de salud extendida
	@echo "ü©∫ Verificaci√≥n de salud EXTENDIDA..."
	@if ! command -v curl >/dev/null; then echo "‚ùå Error: 'curl' no est√° instalado. No se puede verificar la salud de los microservicios."; fi

	@echo "üîç Infraestructura (Health Actuator):"
	$(call check_health, http://localhost:$(DISCOVERY_PORT)/actuator/health, Discovery)
	$(call check_health, http://localhost:$(CONFIG_PORT)/actuator/health, Config)

	@echo "üîç Bases de datos (pg_isready):"
	# Se usa el nombre completo del contenedor para mayor robustez
	#$(Q) podman exec db_product pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Product DB"
	#$(Q) podman exec db_supplier pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Supplier DB"
	#$(Q) podman exec db_tax pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Tax DB"
	$(Q) podman exec db_product pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Product DB"
	$(Q) podman exec db_supplier pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Supplier DB"
	$(Q) podman exec db_tax pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Tax DB"
	$(Q) podman exec db_purchase pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Purchase DB"
	@echo "üîç Microservicios (Health Actuator):"
	$(call check_health, http://localhost:$(PRODUCT_PORT)/actuator/health, Product)
	$(call check_health, http://localhost:$(SUPPLIER_PORT)/actuator/health, Supplier)
	$(call check_health, http://localhost:$(TAX_PORT)/actuator/health, Tax)
	$(call check_health, http://localhost:$(PURCHASE_PORT)/actuator/health, Purchase)
	$(call check_health, http://localhost:$(GATEWAY_PORT)/actuator/health, Gateway)

health-check-extended: podman-ready ## üíö Verificaci√≥n de salud extendida
	@echo "ü©∫ Verificaci√≥n de salud EXTENDIDA..."
	@if ! command -v curl >/dev/null; then echo "‚ùå Error: 'curl' no est√° instalado. No se puede verificar la salud de los microservicios."; fi

	@echo "üîç Infraestructura (Health Actuator):"
	$(call check_health, http://localhost:$(DISCOVERY_PORT)/actuator/health, Discovery)
	$(call check_health, http://localhost:$(CONFIG_PORT)/actuator/health, Config)

	@echo "üîç Bases de datos (pg_isready):"
    # Se usa el nombre completo del contenedor para mayor robustez
    # ‚úÖ A√ëADIR EL GUION (-) AQU√ç PARA IGNORAR EL ERROR 125 SI FALLA
	-$(Q) podman exec db_product pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Product DB"
	-$(Q) podman exec db_supplier pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Supplier DB"
	-$(Q) podman exec db_tax pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Tax DB"
	-$(Q) podman exec db_purchase pg_isready -U postgres >/dev/null 2>&1 && echo "‚úÖ Purchase DB"

	@echo "üîç Microservicios (Health Actuator):"
	$(call check_health, http://localhost:$(PRODUCT_PORT)/actuator/health, Product)
	$(call check_health, http://localhost:$(SUPPLIER_PORT)/actuator/health, Supplier)
	$(call check_health, http://localhost:$(TAX_PORT)/actuator/health, Tax)
	$(call check_health, http://localhost:$(PRUCHASE_PORT)/actuator/health, Purchase)
	$(call check_health, http://localhost:$(GATEWAY_PORT)/actuator/health, Gateway)
#------------------------------------------------------------------------

#üõ†Ô∏è MANTENIMIENTO Y LIMPIEZA
#------------------------------------------------------------------------
fix-container-orphans: ## üßπ Limpiar contenedores hu√©rfanos (Forzado)
	@echo "üßπ Limpiando contenedores hu√©rfanos (Forzado)..."
	# 1. Intenta down normal del proyecto
	$(COMPOSE_LOCAL) down -v --remove-orphans 2>/dev/null || true
	# 2. **Elimina forzadamente** contenedores que empiecen con el nombre del proyecto
	$(Q) podman rm -f $$(podman ps -a --format '{{.Names}}' | grep '^$(COMPOSE_PROJECT_NAME)_') 2>/dev/null || true
	# 3. Elimina contenedores detenidos globalmente (por si el paso 2 falla)
	$(Q) podman rm -f $$(podman ps -aq --filter status=exited) 2>/dev/null || true
	# 4. Purga el sistema
	$(Q) podman system prune -f 2>/dev/null || true

fix-line-endings: ## üõ†Ô∏è Garantizar terminaciones de l√≠nea LF para gradlew
	@echo "üõ†Ô∏è Corrigiendo terminaciones de l√≠nea (dos2unix gradlew)..."
	$(Q) dos2unix $(GRADLEW) 2>/dev/null || \
	{ echo "‚ö†Ô∏è Advertencia: 'dos2unix' no est√° instalado. Aseg√∫rate de que gradlew usa terminaciones LF."; }

clean-all: podman-ready fix-line-endings ## üß® Limpieza completa
	@echo "üß® Limpieza completa..."
	$(Q) $(MAKE) down-all
	$(Q) $(MAKE) clean-podman-prune
	$(Q) $(MAKE) clean-gradle
clean-podman-prune: podman-ready ## üßπ Limpiar recursos de Podman (im√°genes, vol√∫menes, cache)
	# ‚úÖ MODIFICADO: Remover el directorio temporal de autenticaci√≥n
	$(Q) rm -rf $(BUILD_DIR) 2>/dev/null || true
	$(Q) podman system prune -a -f --volumes
clean-gradle: ## üßπ Limpiar cach√© de Gradle
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) clean
reset-local: clean-all up-local-all-ordered ## üîÑ Reinicio completo del entorno local
#------------------------------------------------------------------------

#üß™ SERVICIOS INDIVIDUALES
#------------------------------------------------------------------------
docker-login:
	@echo "üîë Forzando login de Podman/Docker con credenciales de .env.local..."
	@if [ -z "$(DOCKER_USERNAME)" ] || [ -z "$(DOCKER_PASSWORD)" ]; then \
		echo "üî¥ ERROR: DOCKER_USERNAME o DOCKER_PASSWORD no definidos en .env.local."; \
		exit 1; \
	fi
	# Usa pipe para pasar la password. Esto es menos seguro, pero es la √∫nica manera de automatizar sin prompt.
	echo "$(DOCKER_PASSWORD)" | podman login -u "$(DOCKER_USERNAME)" --password-stdin docker.io
	@echo "‚úÖ Login completado."
#üè∑Ô∏è PRODUCT SERVICE
test-product: ## üß™ Tests de Product Service
	$(Q) cd $(ROOT_DIR)/product-service && $(GRADLEW) test
run-product-local: fix-line-endings ## üöÄ Ejecutar Product Service localmente
	@echo "üöÄ Product Service en http://localhost:$(PRODUCT_PORT)"
	$(Q) cd $(ROOT_DIR)/product-service && $(GRADLEW) bootRun --args='--spring.profiles.active=local'
rebuild-product-local: podman-ready fix-line-endings ## üîÅ Reconstruir Product Service
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :product-service:bootJar
	$(Q) $(COMPOSE_LOCAL) --profile product build product-service
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile product up -d product-service

#üè∑Ô∏è SUPPLIER SERVICE
test-supplier: ## üß™ Tests de Supplier Service
	$(Q) cd $(ROOT_DIR)/supplier-service && $(GRADLEW) test
test-purcharse: ## üß™ Tests de Supplier Service
	$(Q) cd $(ROOT_DIR)/purcharse-service && $(GRADLEW) test

run-purchase-local: fix-line-endings ## üöÄ Ejecutar Supplier Service localmente
	@echo "üöÄ Purcharse Service en http://localhost:$(PURCHARSE_PORT)"
	$(Q) cd $(ROOT_DIR)/purcharse-service && $(GRADLEW) bootRun --args='--spring.profiles.active=local'

run-supplier-local: fix-line-endings ## üöÄ Ejecutar Supplier Service localmente
	@echo "üöÄ Supplier Service en http://localhost:$(SUPPLIER_PORT)"
	$(Q) cd $(ROOT_DIR)/supplier-service && $(GRADLEW) bootRun --args='--spring.profiles.active=local'

rebuild-supplier-local: podman-ready fix-line-endings ## üîÅ Reconstruir Supplier Service
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :supplier-service:bootJar
    # ‚ùå ANTES: $(Q) $(COMPOSE_LOCAL) --profile supplier build supplier-service
    # ‚úÖ DESPU√âS: Incluir el perfil 'infra' para resolver dependencias (discovery-service)
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile supplier build supplier-service
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile supplier up -d supplier-service

#üè∑Ô∏è TAX SERVICE
test-tax: ## üß™ Tests de Tax Service
	$(Q) cd $(ROOT_DIR)/tax-service && $(GRADLEW) test

run-tax-local: fix-line-endings ## üöÄ Ejecutar Tax Service localmente
	@echo "üöÄ Tax Service en http://localhost:$(TAX_PORT)"
	$(Q) cd $(ROOT_DIR)/tax-service && $(GRADLEW) bootRun --args='--spring.profiles.active=local'

rebuild-tax-local: podman-ready fix-line-endings ## üîÅ Reconstruir Tax Service
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :tax-service:bootJar
	$(Q) $(COMPOSE_LOCAL) --profile tax build tax-service
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile tax up -d tax-service

rebuild-purchase-local: podman-ready fix-line-endings ## üîÅ Reconstruir Tax Service
	$(Q) cp $(ENV_FILE_LOCAL) .env.override
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :purchase-service:bootJar
	$(Q) $(COMPOSE_LOCAL) --profile purchase build purchase-service
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile purchase up -d purchase-service

# El Purchase Service ha sido eliminado por no estar desarrollado.
#------------------------------------------------------------------------

#üóÉÔ∏è BASE DE DATOS
#------------------------------------------------------------------------
up-db: podman-ready ## üóÉÔ∏è Levantar solo bases de datos
	@echo "üóÑÔ∏è Levantando bases de datos (solo por perfiles)..."
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d db_product db_supplier db_tax db_purchase # Solo levantar los servicios de DB
reset-db: podman-ready ## üóÉÔ∏è Reiniciar base de datos principal
	@echo "üîÑ Reiniciando product-db..."
	$(Q) $(COMPOSE_LOCAL) down -v db_product
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d db_product
	@echo "üîÑ Reiniciando tax-db..."
	$(Q) $(COMPOSE_LOCAL) down -v db_tax
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d db_tax
	@echo "üîÑ Reiniciando supplier-db..."
	$(Q) $(COMPOSE_LOCAL) down -v supplier_tax
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d db_supplier
tax-db-reset: podman-ready fix-line-endings ## üóÉÔ∏è Reiniciar base de datos de tax
	@echo "üîÑ Reiniciando tax-db y tax-service..."
	$(Q) $(COMPOSE_LOCAL) --profile tax down -v tax-db
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :tax-service:bootJar
	$(Q) $(COMPOSE_LOCAL) --profile infra --profile tax up -d tax-service


debug-discovery: podman-ready ## üêõ Debug del Discovery Service
	@echo "üêõ Iniciando diagn√≥stico del Discovery Service..."
	@echo "üìã Estado del contenedor:"
	$(Q) podman ps -a --filter name=$(COMPOSE_PROJECT_NAME)_discovery-service_1
	@echo ""
	@echo "üìú √öltimos logs (100 l√≠neas):"
	$(Q) podman logs $(COMPOSE_PROJECT_NAME)_discovery-service_1 --tail 100 2>/dev/null || echo "‚ùå No se pueden obtener logs del discovery-service"
	@echo ""
	@echo "üîç Verificando recursos de Podman:"
	$(Q) podman system info | grep -E "(CPUs|Memory)" | head -2

fix-discovery: podman-ready fix-line-endings ## üîß Solucionar problemas del Discovery Service (General fix)
	@echo "üîß Aplicando correcciones para Discovery Service..."
	@echo "1. Deteniendo contenedor..."
	$(Q) podman stop $(COMPOSE_PROJECT_NAME)_discovery-service_1 2>/dev/null || true
	$(Q) podman rm $(COMPOSE_PROJECT_NAME)_discovery-service_1 2>/dev/null || true
	@echo "2. Reconstruyendo imagen (SIN CACH√â)..."
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :discovery-service:bootJar
	$(Q) podman build --no-cache -f $(ROOT_DIR)/discovery-service/Dockerfile -t discovery-service:latest $(ROOT_DIR)
	@echo "3. Levantando solo discovery service..."
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d discovery-service
	$(Q) sleep 10
	@echo "5. Verificando logs..."
	$(Q) podman logs $(COMPOSE_PROJECT_NAME)_discovery-service_1 --tail 20

check-discovery-health: podman-ready ## üîç Verificar salud espec√≠fica del Discovery
	@echo "üîç Verificando salud de Discovery Service..."
	@if curl -s http://localhost:$(DISCOVERY_PORT)/actuator/health >/dev/null; then \
		echo "‚úÖ Discovery Service est√° saludable"; \
	else \
		echo "‚ùå Discovery Service no responde"; \
		echo "üìú √öltimos logs:"; \
		$(Q) podman logs $(COMPOSE_PROJECT_NAME)_discovery-service_1 --tail 30 2>/dev/null || echo "No hay logs disponibles"; \
	fi
#------------------------------------------------------------------------

#üìä DIAGN√ìSTICO COMPLETO DEL SISTEMA
diagnose: podman-ready ## üîç Diagn√≥stico completo del sistema
	@echo "üîç Ejecutando diagn√≥stico completo del sistema..."
	@echo ""
	@echo "üìä ESTADO DE CONTENEDORES:"
	$(Q) $(COMPOSE_LOCAL) ps
	@echo ""
	@echo "üíæ RECURSOS DEL SISTEMA:"
	$(Q) podman stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.Status}}" 2>/dev/null || echo "‚ö†Ô∏è No se pudieron obtener estad√≠sticas"
	@echo ""
	@echo "üåê VERIFICACI√ìN DE RED:"
	$(Q) podman network ls
	@echo ""
	@echo "üì¶ VERIFICACI√ìN DE IM√ÅGENES:"
	$(Q) podman images --filter reference="inventory" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
	@echo ""
	@echo "ü©∫ VERIFICACI√ìN DE SALUD:"
	$(Q) $(MAKE) health-check-extended

check-resources: ## üìä Verificar recursos del sistema
	@echo "üìä Verificando recursos de Podman..."
	@echo "üñ•Ô∏è CPUs y Memoria:"
	$(Q) podman system info | grep -E "(CPUs|Memory|Disk)" | head -3
	@echo ""
	@echo "üíæ Uso de disco:"
	$(Q) podman system df
	@echo ""
	@echo "üìà Contenedores activos:"
	$(Q) podman ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

check-ports: ## üîç Verificar puertos en uso
	@echo "üîç Verificando puertos en uso (solo en el host):"
	@if ! command -v lsof >/dev/null; then echo "‚ö†Ô∏è Advertencia: 'lsof' no est√° instalado. No se puede verificar la disponibilidad de puertos del host."; exit 1; fi
	@for port in $(DISCOVERY_PORT) $(CONFIG_PORT) $(GATEWAY_PORT) $(PRODUCT_PORT) $(SUPPLIER_PORT) $(TAX_PORT) 5432; do \
		if lsof -Pi :$$port -sTCP:LISTEN -t >/dev/null; then \
			echo "üî¥ Puerto $$port: OCUPADO"; \
		else \
			echo "üü¢ Puerto $$port: LIBRE"; \
		fi; \
	done

#üêõ HERRAMIENTAS DE DEBUGGING
service-logs: podman-ready ## üìú Ver logs de todos los servicios recientes
	@echo "üìú Mostrando √∫ltimos 50 l√≠neas de logs de cada servicio activo:"
	@for service in $$( $(COMPOSE_LOCAL) ps --services ); do \
		echo ""; \
		echo "=== $$service ==="; \
		$(Q) podman logs $(COMPOSE_PROJECT_NAME)_$$service_1 --tail 50 2>/dev/null | tail -20 || echo "No hay logs disponibles"; \
	done

check-container-status: ## üîç Ver estado detallado de contenedores
	@echo "üîç Estado detallado de contenedores:"
	$(Q) podman ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}"

#üöë COMANDOS DE EMERGENCIA
# --- üß® SUPER LIMPIEZA DE EMERGENCIA (UNIFICADA) ---
emergency-clean: podman-ready ## üß® Borrado total y profundo (Contenedores, Im√°genes, Vol√∫menes y Redes)
	@echo "üß® ADVERTENCIA: Se eliminar√°n TODOS los contenedores, im√°genes y vol√∫menes de Podman."
	@read -p "‚ö†Ô∏è ¬øEst√°s seguro de realizar esta limpieza profunda? (Escribe 'SI' para continuar): " confirm; \
	if [ "$$confirm" = "SI" ]; then \
		echo "üßπ Iniciando limpieza total..."; \
		podman compose -f docker-compose-podman.yml down --volumes --remove-orphans 2>/dev/null || true; \
		echo "üõë Deteniendo y eliminando contenedores..."; \
		podman stop $$(podman ps -aq) 2>/dev/null || true; \
		podman rm -f $$(podman ps -aq) 2>/dev/null || true; \
		echo "üñºÔ∏è Eliminando im√°genes..."; \
		podman rmi -f $$(podman images -aq) 2>/dev/null || true; \
		echo "üìú Limpiando redes y vol√∫menes..."; \
		podman network prune -f; \
		podman volume prune -f; \
		podman system prune -a -f --volumes; \
		echo "‚úÖ Sistema totalmente limpio."; \
		$(MAKE) podman-auth; \
	else \
		echo "‚ùå Limpieza cancelada por el usuario."; \
	fi
restart-podman-vm: ## üîÑ Reiniciar la m√°quina virtual de Podman
	@echo "üîÑ Reiniciando Podman Machine..."
	$(Q) podman machine stop
	$(Q) sleep 5
	$(Q) podman machine start
	@echo "‚úÖ Podman Machine reiniciada"
sync-podman-desktop: ## üçé Sincronizar con Podman Desktop (macOS)
	@echo "üîÑ Sincronizando con Podman Desktop..."
	$(Q) podman system connection default podman-machine-default
	@echo "‚úÖ Podman Desktop sincronizado"
	@echo "üí° Si no ves los contenedores, reinicia Podman Desktop completamente"

fix-discovery-chmod: podman-ready ## üõ†Ô∏è Solucionar espec√≠ficamente el problema de chmod en discovery
	@echo "üõ†Ô∏è Aplicando fix espec√≠fico para discovery service..."
	# 1. Dar permisos en el host
	$(Q) chmod +x $(ROOT_DIR)/discovery-service/entrypoint.sh $(ROOT_DIR)/discovery-service/wait-for-it.sh 2>/dev/null || true
	# 2. Reconstruir JAR
	$(Q) cd $(ROOT_DIR) && $(GRADLEW) :discovery-service:bootJar
	# 3. Reconstruir imagen sin cache (forzando la copia de los scripts)
	$(Q) podman rmi discovery-service:latest 2>/dev/null || true
	$(Q) podman build --no-cache -f $(ROOT_DIR)/discovery-service/Dockerfile -t discovery-service:latest $(ROOT_DIR)
	# 4. Levantar solo discovery
	$(Q) $(COMPOSE_LOCAL) --profile infra up -d discovery-service
	$(Q) sleep 10
	@echo "‚úÖ Fix aplicado, verificando..."
	$(Q) podman logs $(COMPOSE_PROJECT_NAME)_discovery-service_1 --tail 10

diagnose-chmod: ## üîç Diagn√≥stico espec√≠fico de problemas chmod
	@echo "üîç Diagn√≥stico de problemas chmod..."
	@echo ""
	@echo "üìã Permisos de scripts en host:"
	@for service in discovery-service config-service api-gateway product-service supplier-service tax-service purchase-service; do \
		if [ -f "$(ROOT_DIR)/$$service/entrypoint.sh" ]; then \
			echo "$$service/entrypoint.sh: $$(ls -l $(ROOT_DIR)/$$service/entrypoint.sh | cut -d' ' -f1)"; \
		else \
			echo "‚ùå $$service/entrypoint.sh: NO EXISTE"; \
		fi; \
		if [ -f "$(ROOT_DIR)/wait-for-it.sh" ]; then \
			echo "wait-for-it.sh (Root): $$(ls -l $(ROOT_DIR)/wait-for-it.sh | cut -d' ' -f1)"; \
		else \
			echo "‚ùå wait-for-it.sh: NO EXISTE en la ra√≠z"; \
		fi; \
	done
	@echo ""
	@echo "üê≥ Estado de contenedores:"
	$(Q) podman ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}"
#------------------------------------------------------------------------

#üìñ AYUDA Y DOCUMENTACI√ìN
#------------------------------------------------------------------------
help: ## üìñ Mostrar ayuda general
	@echo "ü¶≠ Makefile para Podman - InventoryMS"
	@echo ""
	@echo "üöÄ COMANDOS PRINCIPALES:"
	@echo "	make start	 - Iniciar servicios base (Infra + Product + Gateway)"
	@echo "	make start-all	 - Iniciar todos los servicios (en orden)"
	@echo "	make start-parallel	 - Iniciar todos los servicios (en paralelo)"
	@echo "	make stop	 - Detener todos los servicios"
	@echo "	make restart	 - Reiniciar servicios base"
	@echo "	make restart-all	 - Reiniciar todos los servicios"
	@echo "	make dev-full	 - Entorno de desarrollo completo (ordenado)"
	@echo ""
	@echo "üõ†Ô∏è DESARROLLO:"
	@echo "	make build-all	 - Construir todos los JARs"
	@echo "	make build-images-all-nocache - Forzar la reconstrucci√≥n de todas las im√°genes (ideal si tienes problemas de cach√©)"
	@echo "	make test-all	 - Ejecutar todos los tests"
	@echo "	make status	 - Estado de los servicios"
	@echo "	make logs	 - Logs de todos los servicios"
	@echo "	make health	 - Verificaci√≥n de salud extendida"
	@echo ""
	@echo "üßπ MANTENIMIENTO:"
	@echo "	make clean-all	 - Limpieza completa (detiene, purga podman, limpia gradle)"
	@echo "	make fix-line-endings	 - Corregir terminaciones de l√≠nea de gradlew (CR√çTICO para compatibilidad)"
	@echo "	make reset-local	 - Reinicio completo del entorno local"
	@echo "	make fix-container-orphans - Limpiar contenedores hu√©rfanos"
	@echo ""
	@echo "üîç DIAGN√ìSTICO (TS):"
	@echo "	make diagnose	 - Diagn√≥stico completo del sistema"
	@echo "	make check-ports	 - Verificar puertos en uso en el host"
	@echo "	make debug-discovery	 - Diagn√≥stico espec√≠fico del Discovery Service"
	@echo ""
	@echo "üìñ M√ÅS AYUDA:"
	@echo "	make help-services	 - Comandos por servicio"
	@echo "	make help-db	 - Comandos de base de datos"
	@echo "	make help-troubleshoot	 - Soluci√≥n de problemas avanzada"

help-services: ## üìñ Ayuda de servicios individuales
	@echo "üß™ SERVICIOS INDIVIDUALES:"
	@echo ""
	@echo "üè∑Ô∏è Product Service:"
	@echo "	make run-product-local	 - Ejecutar localmente (host)"
	@echo "	make test-product	 - Ejecutar tests"
	@echo "	make rebuild-product-local - Reconstruir y levantar el contenedor"
	@echo ""
	@echo "üè∑Ô∏è Supplier Service:"
	@echo "	make run-supplier-local	 - Ejecutar localmente (host)"
	@echo "	make test-supplier	 - Ejecutar tests"
	@echo "	make rebuild-supplier-local - Reconstruir y levantar el contenedor"
	@echo ""
	@echo "üè∑Ô∏è Tax Service:"
	@echo "	make run-tax-local	 - Ejecutar localmente (host)"
	@echo "	make test-tax	 - Ejecutar tests"
	@echo "	make rebuild-tax-local	 - Reconstruir y levantar el contenedor"
help-db: ## üìñ Ayuda de bases de datos
	@echo "üóÉÔ∏è BASES DE DATOS:"
	@echo ""
	@echo "	make up-db	 - Levantar solo bases de datos"
	@echo "	make reset-db	 - Reiniciar base de datos principal (product-db)"
	@echo "	make tax-db-reset	 - Reiniciar base de datos de tax y servicio"
help-troubleshoot: ## üìñ Ayuda de soluci√≥n de problemas
	@echo "üÜò SOLUCI√ìN DE PROBLEMAS ESPEC√çFICA:"
	@echo ""
	@echo "üîç DIAGN√ìSTICO:"
	@echo "	make diagnose	 - Diagn√≥stico completo del sistema"
	@echo "	make debug-discovery	 - Diagn√≥stico espec√≠fico del Discovery Service"
	@echo "	make check-ports	 - Verificar puertos en uso"
	@echo "	make service-logs	 - Logs recientes de todos los servicios"
	@echo "	make diagnose-chmod	 - Diagn√≥stico de permisos de ejecuci√≥n (chmod)"
	@echo ""
	@echo "üîß SOLUCIONES:"
	@echo "	make fix-discovery	 - Solucionar problemas del Discovery Service"
	@echo "	make fix-discovery-chmod - Solucionar espec√≠ficamente problemas de permisos en discovery"
	@echo "	make restart-podman-vm	 - Reiniciar la m√°quina virtual de Podman"
	@echo "	make emergency-clean	 - Limpieza completa (¬°USAR CON CUIDADO!)"
	@echo ""
	@echo "üí° CONSEJOS:"
	@echo "	‚Ä¢ Si un servicio falla al iniciar, usa 'make service-logs' para ver el error."
	@echo "	‚Ä¢ Los errores de 'exec format error' suelen ser problemas de permisos. Usa 'make diagnose-chmod' y 'make fix-discovery-chmod'."

.PHONY: up-local-all-ordered up-local-all-optimized
up-local-all-optimized: podman-ready fix-line-endings podman-auth ## üöÄ Iniciar stack optimizado
	@START_SECONDS=$$(date +%s); \
	START_TIME=$$(date +"%Y-%m-%d %H:%M:%S"); \
	echo "================================================================================="; \
	echo "üöÄ INICIO OPTIMIZADO: $$START_TIME"; \
	echo "================================================================================="; \
	\
	$(MAKE) build-jars-all; \
	ALL_PROFILES="--profile infra --profile product --profile supplier --profile tax --profile gateway"; \
	\
	echo "üîß 1/4: Levantando Infraestructura (Discovery & Config)..."; \
	$(COMPOSE_OPTIMIZED) $$ALL_PROFILES up -d discovery-service config-service; \
	echo "‚è±Ô∏è Esperando 20s..."; \
	sleep 20; \
	\
	echo "üóÑÔ∏è 2/4: Levantando Bases de Datos..."; \
	$(COMPOSE_OPTIMIZED) $$ALL_PROFILES up -d db_product db_supplier db_tax; \
	sleep 10; \
	\
	echo "üõ†Ô∏è 3/4: Levantando Microservicios en paralelo..."; \
	$(COMPOSE_OPTIMIZED) $$ALL_PROFILES up -d product-service supplier-service tax-service || (echo "‚ùå Error en MS"; exit 1); \
	echo "‚è±Ô∏è Cargando contextos de Spring (35s)..."; \
	sleep 35; \
	\
	echo "üåê 4/4: Levantando API Gateway..."; \
	$(COMPOSE_OPTIMIZED) $$ALL_PROFILES up -d api-gateway; \
	\
	echo "========================================================="; \
	echo "üìä ESTADO FINAL DE LOS CONTENEDORES"; \
	echo "========================================================="; \
	podman ps --format "{{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "service|db|discovery|config|gateway" | awk -F'\t' '{ \
		status_icon = "‚ùå"; \
		if ($$2 ~ /healthy/) status_icon = "‚úÖ"; \
		else if ($$2 ~ /running/) status_icon = "üü°"; \
		printf "%s %-20s %-25s %s\n", status_icon, $$1, $$2, $$3; \
	}'; \
	\
	END_SECONDS=$$(date +%s); \
	DURATION_SECONDS=$$((END_SECONDS - START_SECONDS)); \
	MINUTES=$$(( (DURATION_SECONDS % 3600) / 60 )); \
	SECONDS=$$((DURATION_SECONDS % 60)); \
	echo "================================================================================="; \
	printf "‚è≥ TIEMPO TOTAL OPTIMIZADO: %02d:%02d\n" $$MINUTES $$SECONDS; \
	echo "================================================================================="; \
	$(MAKE) health-check-extended

.PHONY: help help-services help-db help-troubleshoot start start-all start-parallel \
	stop restart restart-all dev dev-full dev-supplier dev-tax build-all build-jars \
	build-jars-all test-all test-quick status status-all logs health podman-ready ensure-script-exec \
	up-local up-local-all up-local-all-ordered up-local-supplier up-local-with-tax \
	down-local down-all logs-% health-check-extended fix-container-orphans clean-all \
	clean-podman-prune clean-gradle reset-local test-product run-product-local rebuild-product-local \
	test-supplier run-supplier-local rebuild-supplier-local test-tax run-tax-local rebuild-tax-local \
	up-db reset-db tax-db-reset diagnose check-ports \
	sync-podman-desktop debug-discovery fix-discovery check-discovery-health check-resources \
	service-logs check-container-status emergency-clean restart-podman-vm fix-discovery-chmod \
	diagnose-chmod build-images-all-nocache fix-line-endings podman-auth